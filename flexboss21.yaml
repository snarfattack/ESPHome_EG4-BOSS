substitutions:
  name: "flexboss21"
  friendly_name: "FlexBOSS21"
  skipUpdatesHolding: 5
  
esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  on_boot:
    priority: -10
    then:
      - logger.log: "Normal boot"
    
# Throttle writing parameters to the internal flash memory to reduce ESP memory wear / degradation
preferences:
  flash_write_interval: 15min

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
    level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key
  on_client_connected: 
    then:
      - switch.turn_on: led_ha_api
  on_client_disconnected: 
    then:
      - switch.turn_off: led_ha_api    

ota:
  - platform: esphome
    password: !secret ota_key

time: # this will push the time from HA to ESPHome, so we can properly parse and display the inverter time from the holding registers
  - platform: homeassistant
    id: homeassistant_time
    
# Configure UART / RS485
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO4
  baud_rate: 19200
  parity: NONE
  stop_bits: 1
    
# Ethernet Controller
ethernet:
  type: IP101
  id: int_eth
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  power_pin: GPIO5
  phy_addr: 1
  clk:
    pin: GPIO0
    mode: CLK_OUT

# Configure Modbus (which runs on top of RS485)
modbus:
  id: mb
  uart_id: rs485_uart
  flow_control_pin:
    number: GPIO32   # DE + /RE tied together
    inverted: true

modbus_controller:
  - id: inverter_1
    address: 1        # inverter_1 Modbus address
    modbus_id: mb
    update_interval: 10s
    #command_throttle: 2ms

binary_sensor:
  - platform: template
    name: "Ethernet DHCP Active"
    id: eth_dhcp_status
    internal: true
    lambda: |-
      return id(int_eth).is_connected();
    on_state:
      then: 
        - lambda: |-
            if (id(eth_dhcp_status).state) {
              id(led_network).turn_on();
            } else {
              id(led_network).turn_off();
            };

  - platform: template
    name: "AC Couple Enabled"
    id: ACCoupleEnabled
    #Published from Sensor, register 77

  - platform: template
    name: "Smart Load On"
    id: SmartLoadEnOn
    #Published from Sensor, register 77
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Alarm CH1"
    id: AFCIFlag_ArcAlarmCH1
    register_type: read
    address: 144
    bitmask: 0x00
    device_class: problem

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Alarm CH2"
    id: AFCIFlag_ArcAlarmCH2
    register_type: read
    address: 144
    bitmask: 0x01
    device_class: problem

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Alarm CH3"
    id: AFCIFlag_ArcAlarmCH3
    register_type: read
    address: 144
    bitmask: 0x02
    device_class: problem

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Alarm CH4"
    id: AFCIFlag_ArcAlarmCH4
    register_type: read
    address: 144
    bitmask: 0x03
    device_class: problem

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Self Test Result CH1"
    id: AFCIFlag_SelfTestResultCH1
    register_type: read
    address: 144
    bitmask: 0x04
    device_class: problem

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Self Test Result CH2"
    id: AFCIFlag_SelfTestResultCH2
    register_type: read
    address: 144
    bitmask: 0x05
    device_class: problem
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Self Test Result CH3"
    id: AFCIFlag_SelfTestResultCH3
    register_type: read
    address: 144
    bitmask: 0x06
    device_class: problem
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Self Test Result CH4"
    id: AFCIFlag_SelfTestResultCH4
    register_type: read
    address: 144
    bitmask: 0x07
    device_class: problem
    
sensor:
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV1 Voltage"
    id: Vpv1
    register_type: read
    address: 1
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV2 Voltage"
    id: Vpv2
    register_type: read
    address: 2
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV3 Voltage"
    id: Vpv3
    register_type: read
    address: 3
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Voltage"
    id: Vbat
    register_type: read
    address: 4
    unit_of_measurement: "V"
    state_class: measurement
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: raw_battery_status
    address: 5
    register_type: read
    value_type: U_WORD
    internal: true        # Hides this raw sensor from Home Assistant
    on_value:
      then:
        - lambda: |-
            // Extract values from the packed 0xHHLL word
            int raw = int(x);
            int soc_val = raw & 0xFF;        // Lower 8 bits (LL)
            int soh_val = (raw >> 8) & 0xFF; // Upper 8 bits (HH)
            
            // Push values to the template sensors
            id(SOC).publish_state(soc_val);
            id(SOH).publish_state(soh_val);

  - platform: template
    name: "Battery State of Charge"
    id: SOC
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0

  - platform: template
    name: "Battery State of Health"
    id: SOH
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Internal Fault"
    id: FaultInternal
    register_type: read
    address: 6
    value_type: U_WORD
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV1 Power"
    id: Ppv1
    register_type: read
    address: 7
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
 
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV2 Power"
    id: Ppv2
    register_type: read
    address: 8
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV3 Power"
    id: Ppv3
    register_type: read
    address: 9
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Charge Power"
    id: Pcharge
    register_type: read
    address: 10
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge Power"
    id: Pdischarge
    register_type: read
    address: 11
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

    # this is Phase R or Split Phase grid voltage
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage"
    id: VacR
    register_type: read
    #register_count: 4
    address: 12
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

    # this is Phase S grid voltage
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage - S"
    id: VacS
    register_type: read
    #register_count: 4
    address: 13
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

    # this is Phase T grid voltage
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage - T"
    id: VacT
    register_type: read
    #register_count: 4
    address: 14
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Frequency"
    id: Fac
    register_type: read
    address: 15
    unit_of_measurement: "Hz"
    device_class: frequency
    accuracy_decimals: 2
    value_type: U_WORD
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Power On Grid"
    id: Pinv
    register_type: read
    address: 16
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charging Rectified Power"
    id: Prec
    register_type: read
    address: 17
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Current RMS"
    id: IinvRMS
    register_type: read
    address: 18
    unit_of_measurement: A
    device_class: current
    value_type: U_WORD
    filters: 
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Power Factor"
    id: PF
    register_type: read
    address: 19
    unit_of_measurement: "%"
    device_class: power_factor
    value_type: S_WORD
    filters: 
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Voltage"
    id: VepsR
    register_type: read
    address: 20
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Voltage - S"
    id: VepsS
    register_type: read
    address: 21
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Voltage - T"
    id: VepsT
    register_type: read
    address: 22
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Port Frequency"
    id: Feps
    register_type: read
    address: 23
    unit_of_measurement: "Hz"
    device_class: frequency
    accuracy_decimals: 2
    value_type: U_WORD
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Port Power"
    id: Peps
    register_type: read
    address: 24
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Apparent Power"
    id: Seps
    register_type: read
    address: 25
    unit_of_measurement: "VA"
    device_class: apparent_power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Power"
    id: Ptogrid
    register_type: read
    address: 26
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Power"
    id: Ptouser
    register_type: read
    address: 27
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV1 Energy (Today)"
    id: Epv1_day
    register_type: read
    address: 28
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV2 Energy (Today)"
    id: Epv2_day
    register_type: read
    address: 29
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV3 Energy (Today)"
    id: Epv3_day
    register_type: read
    address: 30
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "On-Grid Energy (Today)"
    id: Einv_day
    register_type: read
    address: 31
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charging Rectified Energy (Today)"
    id: Erec_day
    register_type: read
    address: 32
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Charge Energy (Today)"
    id: Echg_day
    register_type: read
    address: 33
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge Energy (Today)"
    id: Edischg_day
    register_type: read
    address: 34
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Energy (Today)"
    id: Eeps_day
    register_type: read
    address: 35
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Energy (Today)"
    id: Etogrid_day
    register_type: read
    address: 36
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Energy (Today)"
    id: Etouser_day
    register_type: read
    address: 37
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Bus 1 Voltage"
    id: Vbus1
    register_type: read
    address: 38
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
            
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Bus 2 Voltage"
    id: Vbus2
    register_type: read
    address: 39
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV1 Energy (Total)"
    id: Epv1_all
    register_type: read
    address: 40
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV2 Energy (Total)"
    id: Epv2_all
    register_type: read
    address: 42
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV3 Energy (Total)"
    id: Epv3_all
    register_type: read
    address: 44
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Energy (Total)"
    id: Einv_all
    register_type: read
    address: 46
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charging Rectified Energy (Total)"
    id: Erec_all
    register_type: read
    address: 48
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Charge Energy (Total)"
    id: Echg_all
    register_type: read
    address: 50
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge Energy (Total)"
    id: Edischg_all
    register_type: read
    address: 52
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Energy (Total)"
    id: Eeps_all
    register_type: read
    address: 54
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Energy (Total)"
    id: Etogrid_all
    register_type: read
    address: 56
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Energy (Total)"
    id: Etouser_all
    register_type: read
    address: 58
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Fault Codes"
    id: FaultCode
    register_type: read
    address: 60
    accuracy_decimals: 0
    value_type: U_DWORD_R
    entity_category: diagnostic
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Warning Code"
    id: WarningCode
    register_type: read
    address: 62
    accuracy_decimals: 0
    value_type: U_DWORD_R
    entity_category: diagnostic
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature Internal Ring"
    id: Tinner
    register_type: read
    address: 64
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature Radiator 1"
    id: Tradiator1
    register_type: read
    address: 65
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature Radiator 2"
    id: Tradiator2
    register_type: read
    address: 66
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature Battery"
    id: Tbat
    register_type: read
    register_count: 2  #read register 68 as well to improve performance reading registers, but ignore it as we don't know what it is.
    address: 67
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Runtime"
    id: RunningTime
    register_type: read
    address: 69
    accuracy_decimals: 0
    value_type: U_DWORD_R
    unit_of_measurement: 's'
    state_class: total_increasing
    device_class: duration

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ATS_raw
    register_type: read
    address: 71
    accuracy_decimals: 0
    internal: true
    value_type: U_WORD
    on_value: 
      then:
        - lambda: |-
            // 1. Extract bits 0-3
            uint16_t val1 = (uint16_t)x & 0x000F; 
            switch (val1) {
              case 0: id(ubAutoTestStart).publish_state("Not activated"); break;
              case 1: id(ubAutoTestStart).publish_state("Activated"); break;
              default: id(ubAutoTestStart).publish_state("Unknown"); break;
            }

            // 2. Extract bits 4-7 (Note: using a different variable name or just reusing without redeclaring)
            uint16_t val2 = ((uint16_t)x >> 4) & 0x000F;
            switch (val2) {
              case 0: id(ubAutoTestStatus).publish_state("Waiting"); break;
              case 1: id(ubAutoTestStatus).publish_state("Testing"); break;
              case 2: id(ubAutoTestStatus).publish_state("Test fail"); break;
              case 3: id(ubAutoTestStatus).publish_state("V Test OK"); break;
              case 4: id(ubAutoTestStatus).publish_state("F Test OK"); break;
              case 5: id(ubAutoTestStatus).publish_state("Test Pass"); break;
              default: id(ubAutoTestStatus).publish_state("Unknown"); break;
            }
            
            // 3. Extract bits 8-11
            uint16_t val3 = ((uint16_t)x >> 8) & 0x000F;
            switch (val3) {
              case 1: id(ubAutoTestStep).publish_state("V1L Test"); break;
              case 2: id(ubAutoTestStep).publish_state("V1H Test"); break;
              case 3: id(ubAutoTestStep).publish_state("F1L Test"); break;
              case 4: id(ubAutoTestStep).publish_state("F1H Test"); break;
              case 5: id(ubAutoTestStep).publish_state("V2L Test"); break;
              case 6: id(ubAutoTestStep).publish_state("V2H Test"); break;
              case 7: id(ubAutoTestStep).publish_state("F2L Test"); break;
              case 8: id(ubAutoTestStep).publish_state("F2H Test"); break;
              default: id(ubAutoTestStep).publish_state("Unknown"); break;
            }

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ATL_raw
    register_type: read
    address: 72
    accuracy_decimals: 0
    internal: true
    value_type: U_WORD
    on_value: 
      then:
        - lambda: |-
            float raw = float(x);
            int step = (int)id(ATS_raw).state;
            switch (step) {
              case 1:
              case 2:
              case 5:
              case 6:
                id(wAutoTestLimit).publish_state(str_sprintf("%.1fV", raw*0.1)); 
                break;
              case 3:
              case 4:
              case 7:
              case 8:
                id(wAutoTestLimit).publish_state(str_sprintf("%.2fHz", raw*0.01)); 
                break;
              default:
                id(wAutoTestLimit).publish_state("Unknown"); 
            }
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Auto Test Default Time"
    id: uwAutoTestDefaultTime
    register_type: read
    address: 73
    accuracy_decimals: 0
    value_type: U_WORD
    unit_of_measurement: 'ms'
    device_class: duration

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ATV_raw
    register_type: read
    address: 74
    accuracy_decimals: 0
    internal: true
    value_type: U_WORD
    on_value: 
      then:
        - lambda: |-
            float raw = float(x);
            int step = (int)id(ATS_raw).state;
            switch (step) {
              case 1:
              case 2:
              case 5:
              case 6:
                id(wAutoTestLimit).publish_state(str_sprintf("%.1fV", raw*0.1)); 
                break;
              case 3:
              case 4:
              case 7:
              case 8:
                id(wAutoTestLimit).publish_state(str_sprintf("%.2fHz", raw*0.01)); 
                break;
              default:
                id(wAutoTestLimit).publish_state("Unknown"); 
            }

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Auto Test Trip Time"
    id: uwAutoTestTripTime
    register_type: read
    register_count: 2  #read next register as well to improve performance reading registers, but ignore it as we don't know what it is.
    address: 75
    accuracy_decimals: 0
    value_type: U_WORD
    unit_of_measurement: 'ms'
    device_class: duration

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACInputTypeFlags2
    register_type: read
    register_count: 3  #read next register as well to improve performance reading registers, but ignore it as we don't know what it is.
    address: 77
    internal: true
    on_value:
      then:
        lambda: |-
          // Convert the float/int value to a 16-bit integer
          uint16_t val = (uint16_t)x;
          // Extract Bit 0: AC Input Type
          if ((val >> 0) & 1) {
            id(ACInputType).publish_state("Generator");
          } else {
            id(ACInputType).publish_state("Grid");
          }
          // Extract Bit 1: AC Couple Inverter Flow
          if ((val >> 1) & 1) {
            id(ACCoupleInverterFlow).publish_state("No Flow");
          } else {
            id(ACCoupleInverterFlow).publish_state("Show Flow");
          }
          // Extract Bit 2: AC Couple Enable
          if ((val >> 2) & 1) {
            id(ACCoupleEnabled).publish_state(true);
          } else {
            id(ACCoupleEnabled).publish_state(false);
          }
          // Extract Bit 3: Smart Load Flow
          if ((val >> 3) & 1) {
            id(SmartLoadFlow).publish_state("No Flow");
          } else {
            id(SmartLoadFlow).publish_state("Show Flow");
          }
          // Extract Bit 4: Smart Load Enabled and On
          if ((val >> 4) & 1) {
            id(SmartLoadEnOn).publish_state(true);
          } else {
            id(SmartLoadEnOn).publish_state(false);
          }
          // Extract Bit 5: EPS Load Power Show
          if ((val >> 5) & 1) {
            id(EpsLoadPowerShow).publish_state("No Power Display");
          } else {
            id(EpsLoadPowerShow).publish_state("Power Display");
          }
          // Extract Bit 6: Grid Load Power Show
          if ((val >> 6) & 1) {
            id(GridLoadPowerShow).publish_state("No Power Display");
          } else {
            id(GridLoadPowerShow).publish_state("Power Display");
          }
          // Extract Bit 7: Total Load Power Show
          if ((val >> 7) & 1) {
            id(PLoadPowerShow).publish_state("No Power Display");
          } else {
            id(PLoadPowerShow).publish_state("Power Display");
          }


# TODO. There are two values stored here, Will take some trial and error due to lack of documentation
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Type and Brand"
    id: batTypeandBrand
    register_type: read
    address: 80
    accuracy_decimals: 0
    value_type: U_WORD
    lambda: |-
      int raw = int(x);
      return raw & 0xFF; // Lower 8 bits

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Max Charge Current"
    id: MaxChgCurr
    register_type: read
    address: 81
    unit_of_measurement: A
    device_class: current
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Max Discharge Current"
    id: MaxDischgCurr
    register_type: read
    address: 82
    unit_of_measurement: A
    device_class: current
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Recommended Charging Voltage"
    id: ChargeVoltRef
    register_type: read
    address: 83
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Recommended Discharge Cut-off Voltage"
    id: DischgCutVolt
    register_type: read
    address: 84
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 0"
    id: BatStatus0_BMS
    register_type: read
    address: 85
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 1"
    id: BatStatus1_BMS
    register_type: read
    address: 86
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 2"
    id: BatStatus2_BMS
    register_type: read
    address: 87
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 3"
    id: BatStatus3_BMS
    register_type: read
    address: 88
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 4"
    id: BatStatus4_BMS
    register_type: read
    address: 89
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 5"
    id: BatStatus5_BMS
    register_type: read
    address: 90
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 6"
    id: BatStatus6_BMS
    register_type: read
    address: 91
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 7"
    id: BatStatus7_BMS
    register_type: read
    address: 92
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 8"
    id: BatStatus8_BMS
    register_type: read
    address: 93
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information 9"
    id: BatStatus9_BMS
    register_type: read
    address: 94
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Status Information Summary"
    id: BatStatus_INV
    register_type: read
    address: 95
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Batteries in Parallel"
    id: BatParallelNum
    register_type: read
    address: 96
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Capacity"
    id: BatCapacity
    register_type: read
    address: 97
    unit_of_measurement: Ah
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Current"
    id: BatCurrent_BMS
    register_type: read
    address: 98
    unit_of_measurement: A
    device_class: current
    value_type: S_WORD
    filters: 
      - multiply: 0.1
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Fault Code"
    id: FaultCode_BMS
    register_type: read
    address: 99
    accuracy_decimals: 0
    value_type: U_WORD
        
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Warning Code"
    id: WarningCode_BMS
    register_type: read
    address: 100
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Voltage Cell Max"
    id: MaxCellVolt_BMS
    register_type: read
    address: 101
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    value_type: U_WORD
    filters: 
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Voltage Cell Min"
    id: MinCellVolt_BMS
    register_type: read
    address: 102
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    value_type: U_WORD
    filters: 
      - multiply: 0.001
    on_value: 
      then:
        - lambda: |-
            id(DeltaCellVolt_BMS).publish_state(id(MaxCellVolt_BMS).state - id(MinCellVolt_BMS).state);

  - platform: template
    accuracy_decimals: 3
    unit_of_measurement: "V"
    device_class: voltage
    name: "BMS Voltage Cell Delta"
    id: DeltaCellVolt_BMS   

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature BMS Cell Max"
    id: MaxCellTemp_BMS
    register_type: read
    address: 103
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature BMS Cell Min"
    id: MinCellTemp_BMS
    register_type: read
    address: 104
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Battery Cycle Count"
    id: CycleCnt_BMS
    register_type: read
    address: 106
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Battery Voltage Sample"
    id: BatVoltSample_INV
    register_type: read
    address: 107
    unit_of_measurement: "V"
    accuracy_decimals: 1
    value_type: U_WORD
    device_class: voltage
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature T1"
    id: T1
    register_type: read
    address: 108
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature T2"
    id: T2
    register_type: read
    address: 109
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature T3"
    id: T3
    register_type: read
    address: 110
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature T4"
    id: T4
    register_type: read
    address: 111
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature T5"
    id: T5
    register_type: read
    address: 112
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: InverterParellelFlags
    register_type: read
    address: 113
    internal: true
    on_value:
      then:
        lambda: |-
          // Convert input to an integer for bitwise operations
          uint16_t val = (uint16_t)x;

          // bit0-1: 1-master, 2-slave (Mask: 0x03)
          int role = val & 0x03;
          if (role == 1) id(MasterOrSlave).publish_state("Master");
          else if (role == 2) id(MasterOrSlave).publish_state("Slave");
          else id(MasterOrSlave).publish_state("Unknown");

          // bit2-3: 1-R, 2-S, 3-T (Mask: 0x0C, then shift 2)
          int phase = (val >> 2) & 0x03;
          if (phase == 1) id(SingleOrThreePhase).publish_state("R");
          else if (phase == 2) id(SingleOrThreePhase).publish_state("S");
          else if (phase == 3) id(SingleOrThreePhase).publish_state("T");
          else id(SingleOrThreePhase).publish_state("Unknown");

          // bit4-5: 0-Positive, 1-Negative (Mask: 0x30, then shift 4)
          int polarity = (val >> 4) & 0x03;
          if (polarity == 0) id(PhasesSequence).publish_state("Positive");
          else if (polarity == 1) id(PhasesSequence).publish_state("Negative");
          else id(PhasesSequence).publish_state("Unknown");

          // bit8-15 (Standard 16-bit register): Parallel Number
          // We shift right by 6 to remove bits 0-7
          int parallel_num = val >> 8;
          id(ParallelNum).publish_state(parallel_num);

  - platform: template
    name: "Number of Parallel Inverters"
    id: ParallelNum

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Load Power On Grid (12K)"
    id: Ploadongrid12k
    register_type: read
    address: 114
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Half BUS Voltage"
    id: VBusP
    register_type: read
    address: 120
    unit_of_measurement: "V"
    state_class: measurement
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Voltage"
    id: GenVolt
    register_type: read
    address: 121
    unit_of_measurement: "V"
    state_class: measurement
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Frequency"
    id: GenFreq
    register_type: read
    address: 122
    unit_of_measurement: "Hz"
    device_class: frequency
    accuracy_decimals: 2
    value_type: U_WORD
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Power"
    id: GenPower
    register_type: read
    address: 123
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Energy (Day)"
    id: Egen_day
    register_type: read
    address: 124
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Energy (Total)"
    id: Egen_all
    register_type: read
    address: 125
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    force_new_range: true
    name: "EPS Voltage L1N"
    id: EPSVoltL1N
    register_type: read
    address: 127
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Voltage L2N"
    id: EPSVoltL2N
    register_type: read
    address: 128
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L1N"
    id: Peps_L1N
    register_type: read
    address: 129
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L2N"
    id: Peps_L2N
    register_type: read
    address: 130
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Apparent Power L1N"
    id: Seps_L1N
    register_type: read
    address: 131
    unit_of_measurement: "VA"
    device_class: apparent_power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Apparent Power L2N"
    id: Seps_L2N
    register_type: read
    address: 132
    unit_of_measurement: "VA"
    device_class: apparent_power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L1N (Day)"
    id: EepsL1N_day
    register_type: read
    address: 133
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L2N (Day)"
    id: EepsL2N_day
    register_type: read
    address: 134
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L1N (Total)"
    id: EepsL1N_all
    register_type: read
    address: 135
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power L2N (Total)"
    id: EepsL2N_all
    register_type: read
    address: 137
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Reactive Power"
    id: Qinv
    register_type: read
    address: 139
    unit_of_measurement: "Var"
    device_class: reactive_power
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI current CH1"
    id: AFCI_CurrCH1
    register_type: read
    address: 140
    unit_of_measurement: mA
    device_class: current
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI current CH2"
    id: AFCI_CurrCH2
    register_type: read
    address: 141
    unit_of_measurement: mA
    device_class: current
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI current CH3"
    id: AFCI_CurrCH3
    register_type: read
    address: 142
    unit_of_measurement: mA
    device_class: current
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI current CH4"
    id: AFCI_CurrCH4
    register_type: read
    address: 143
    unit_of_measurement: mA
    device_class: current
    value_type: U_WORD

  #Adding this for some debugging and monitoring of the raw values... some of the AFCI values are not making sense.
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Flags"
    id: AFCIFlags
    register_type: read
    address: 144
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc CH1"
    id: AFCI_ArcCH1
    register_type: read
    address: 145
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc CH2"
    id: AFCI_ArcCH2
    register_type: read
    address: 146
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc CH3"
    id: AFCI_ArcCH3
    register_type: read
    address: 147
    accuracy_decimals: 0
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc CH4"
    id: AFCI_ArcCH4
    register_type: read
    address: 148
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Max CH1"
    id: AFCI_MaxArcCH1
    register_type: read
    address: 149
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Max CH2"
    id: AFCI_MaxArcCH2
    register_type: read
    address: 150
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Max CH3"
    id: AFCI_MaxArcCH3
    register_type: read
    address: 151
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AFCI Arc Max CH4"
    id: AFCI_MaxArcCH4
    register_type: read
    address: 152
    accuracy_decimals: 0
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Couple Power"
    id: ACCouplePower
    register_type: read
    address: 153
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
    
#TODO have some more sensors to add here that I missed.

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Load Power On Grid"
    id: Ploadongrid
    register_type: read
    address: 170
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Load Energy (Total)"
    id: Eload_all
    register_type: read
    address: 172
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 1
    value_type: U_DWORD_R
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Switch State"
    id: SwitchState
    register_type: read
    address: 174
    accuracy_decimals: 0
    value_type: U_WORD
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Power On Grid - S"
    id: PinvGridS
    register_type: read
    address: 180
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Power On Grid - T"
    id: PinvGridT
    register_type: read
    address: 181
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charging Rectified Power - S"
    id: PinvChgS
    register_type: read
    address: 182
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charging Rectified Power - T"
    id: PinvChgT
    register_type: read
    address: 183
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Power - S"
    id: PtoGridS
    register_type: read
    address: 184
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Power - T"
    id: PtoGridT
    register_type: read
    address: 185
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Power - S"
    id: PtoUserS
    register_type: read
    address: 186
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Power - T"
    id: PtoUserT
    register_type: read
    address: 187
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Current RMS - S"
    id: IinvRMSS
    register_type: read
    address: 190
    unit_of_measurement: A
    device_class: current
    value_type: U_WORD
    filters: 
      - multiply: 0.01
      
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Current RMS - T"
    id: IinvRMST
    register_type: read
    address: 191
    unit_of_measurement: A
    device_class: current
    value_type: U_WORD
    filters: 
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Power Factor - S"
    id: PF_S
    register_type: read
    address: 192
    unit_of_measurement: "%"
    device_class: power_factor
    value_type: S_WORD
    filters: 
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Power Factor - T"
    id: PF_T
    register_type: read
    address: 205
    unit_of_measurement: "%"
    device_class: power_factor
    value_type: S_WORD
    filters: 
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage L1N"
    id: VgridL1N
    register_type: read
    address: 193
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage L2N"
    id: VgridL2N
    register_type: read
    address: 194
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Voltage L1N"
    id: VgenL1N
    register_type: read
    address: 195
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1
       
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Generator Voltage L2N"
    id: VgenL2N
    register_type: read
    address: 196
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Power L1N"
    id: PinvL1N
    register_type: read
    address: 197
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Power L2N"
    id: PinvL2N
    register_type: read
    address: 198
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Rectified Power L1N"
    id: PrecL1N
    register_type: read
    address: 199
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Rectified Power L2N"
    id: PrecL2N
    register_type: read
    address: 200
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
        
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Power L1N"
    id: PtogridL1N
    register_type: read
    address: 201
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
        
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Export Power L2N"
    id: PtogridL2N
    register_type: read
    address: 202
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Power L1N"
    id: PtoUserL1N
    register_type: read
    address: 203
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD
        
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Import Power L2N"
    id: PtoUserL2N
    register_type: read
    address: 204
    unit_of_measurement: "W"
    device_class: power
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Remaining Charge Time"
    id: RemainingChargeTime
    register_type: read
    address: 210
    accuracy_decimals: 0
    value_type: U_DWORD_R
    unit_of_measurement: 's'
    device_class: duration

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature INDC"
    id: Tindc
    register_type: read
    address: 214
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature DCDCL"
    id: Tdcdcl
    register_type: read
    address: 215
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature DCDCH"
    id: Tdcdch
    register_type: read
    address: 216
    device_class: temperature
    unit_of_measurement: "C"
    value_type: S_WORD
    state_class: measurement

#Holding Registers ***************************************************************

  # published from text sensor for register 7
  - platform: template
    name: "Version Cntl"
    id: cntlVer
    accuracy_decimals: 0     

  # published from text sensor for register 7
  - platform: template
    name: "Version Com"
    id: comVer
    accuracy_decimals: 0   
    

              
    
text_sensor:
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Working Mode"
    id: state
    register_type: read
    address: 0
    raw_encode: HEXBYTES     # read the 16-bit value as a 4-char hex string
    lambda: |-
      // x is the hex string, for example: "0000", "0010", "00C0".
      // Map values exactly as listed in the table; do not use bitmasking.
      if (x == "0000") return std::string("Standby");
      if (x == "0001") return std::string("Fault");
      if (x == "0002") return std::string("Programming");
      if (x == "0004") return std::string("PV On-Grid");
      if (x == "0008") return std::string("PV Charge");
      if (x == "000c") return std::string("PV Charge + On-Grid");
      if (x == "0010") return std::string("Battery On-Grid");
      if (x == "0014") return std::string("PV + Battery On-Grid");
      if (x == "0020") return std::string("AC Charge");
      if (x == "0028") return std::string("PV + AC Charge");
      if (x == "0040") return std::string("Battery Off-Grid");
      if (x == "0060") return std::string("Off-Grid + Battery Charging (AC-Coupled)");
      if (x == "0080") return std::string("PV Off-Grid (Not Recommended)");
      if (x == "0088") return std::string("PV Charge + Off-Grid");
      if (x == "00c0") return std::string("PV + Battery Off-Grid");
      // Fallback: If the code is not recognized, show the raw hex value.
      return std::string("Unknown (0x") + x + ")";

  - platform: template
    name: "Auto Test Activated"
    id: ubAutoTestStart
  
  - platform: template
    name: "Auto Test Status"
    id: ubAutoTestStatus
  
  - platform: template
    name: "Auto Test Step"
    id: ubAutoTestStep

  - platform: template
    name: "Auto Test Limit"
    id: wAutoTestLimit

  - platform: template
    name: "Auto Test Trip Value"
    id: uwAutoTestTripValue      

  - platform: template
    name: "AC Input Type"
    id: ACInputType
    #Published from Sensor, register 77
    
  - platform: template
    name: "AC Couple Inverter Flow"
    id: ACCoupleInverterFlow
    #Published from Sensor, register 77
    
  - platform: template
    name: "Smart Load Flow"
    id: SmartLoadFlow
    #Published from Sensor, register 77

  - platform: template
    name: "EPS Load Power Show"
    id: EpsLoadPowerShow
    #Published from Sensor, register 77

  - platform: template
    name: "Grid Load Power Show"
    id: GridLoadPowerShow
    #Published from Sensor, register 77

  - platform: template
    name: "Total Load Power Show"
    id: PLoadPowerShow
    #Published from Sensor, register 77
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Communication Type"
    id: batComType
    register_type: read
    address: 80
    raw_encode: NONE
    lambda: |-
      // Modbus registers are 16-bit (2 bytes). 
      // data[item->offset] is the high byte (upper 8 bits).
      // data[item->offset + 1] is the low byte.
      int raw = data[item->offset]; 
      if (raw == 0) return std::string("CAN");
      if (raw == 1) return std::string("RS485");
      return "Unknown " + std::to_string(raw);    

#TODO there are more sensors here to process based on the luxpower modbus documentation
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "BMS Firmware Update State"
    id: BMSFWUpdateState
    register_type: read
    address: 105
    raw_encode: HEXBYTES     # read the 16-bit value as a 4-char hex string
    lambda: |-
      // x is the hex string, for example: "0000", "0010", "00C0".
      // Map values exactly as listed in the table; do not use bitmasking.
      if (x == "0000") return std::string("");
      if (x == "0001") return std::string("Upgrading");
      if (x == "0002") return std::string("Upgrading Successful");
      if (x == "0003") return std::string("Upgrading Failed");
      // Fallback: If the code is not recognized, show the raw hex value.
      return std::string("Unknown (0x") + x + ")";

  - platform: template
    name: "Master or Slave"
    id: MasterOrSlave

  - platform: template
    name: "Single Or Three Phase"
    id: SingleOrThreePhase

  - platform: template
    name: "Phases Sequence"
    id: PhasesSequence

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Serial Number"
    address: 115 
    register_type: read
    register_count: 5
    response_size: 10
    raw_encode: NONE 
    lambda: |-
      std::string serial = "";
      // item->offset is the starting point in the 'data' vector for THIS sensor
      size_t start = item->offset;
      
      // Ensure we don't read past the end of the data vector
      for (int i = 0; i < 10 && (start + i + 1) < data.size(); i += 2) {
          // Swap logic: Read High Byte then Low Byte (standard "swapped" string)
          // Adjust order here if your specific device is different
          char high_byte = (char)data[start + i + 1];
          char low_byte = (char)data[start + i];
          
          if (high_byte >= 32 && high_byte <= 126) serial += high_byte;
          if (low_byte >= 32 && low_byte <= 126) serial += low_byte;
      }
      return serial;
      
# Holding registers ********************************************

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Serial Number - Holding"
    address: 2
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    register_count: 5
    response_size: 10
    raw_encode: NONE 
    lambda: |-
      std::string serial = "";
      // item->offset is the starting point in the 'data' vector for THIS sensor
      size_t start = item->offset;
      
      // Ensure we don't read past the end of the data vector
      for (int i = 0; i < 10 && (start + i + 1) < data.size(); i += 2) {
          // Swap logic: Read High Byte then Low Byte (standard "swapped" string)
          // Adjust order here if your specific device is different
          char high_byte = (char)data[start + i + 1];
          char low_byte = (char)data[start + i];
          
          if (high_byte >= 32 && high_byte <= 126) serial += high_byte;
          if (low_byte >= 32 && low_byte <= 126) serial += low_byte;
      }
      return serial;  

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Firmware"
    address: 7
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    register_count: 8
    response_size: 8
    raw_encode: NONE 
    lambda: |-
      std::string serial = "";
      // item->offset is the starting point in the 'data' vector for THIS sensor
      size_t start = item->offset;
      
      // For the first 2 registers, render each byte as an ASCII character
      for (int i = 0; i < 4 && (start + i + 1) < data.size(); i += 2) {
          // Swap logic: Read High Byte then Low Byte (standard "swapped" string)
          // Adjust order here if your specific device is different
          char high_byte = (char)data[start + i + 1];
          char low_byte = (char)data[start + i];
          
          if (high_byte >= 32 && high_byte <= 126) serial += high_byte;
          if (low_byte >= 32 && low_byte <= 126) serial += low_byte;
      }
      serial += "-";
      //For these values, render the hex value of the byte as a string
      //This is a bit of an educated guess this is where the last half of the firmware version is coming from
      if (start + 7 < data.size()) {
          char hex_buf[3];
          snprintf(hex_buf, sizeof(hex_buf), "%02X", (uint8_t)data[start + 4]);
          serial += hex_buf;
          snprintf(hex_buf, sizeof(hex_buf), "%02X", (uint8_t)data[start + 7]);
          serial += hex_buf;
      }

      //Get these values and publish them into the templates to reduce modbus calls for the same registers.
      uint8_t val = (uint8_t)data[start + 5];
      id(comVer).publish_state(val);
      val = (uint8_t)data[start + 6];
      id(cntlVer).publish_state(val);

      return serial;  

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Inverter Time"
    id: inverter_time
    device_class: timestamp
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    address: 12
    register_count: 3
    response_size: 6
    entity_category: diagnostic
    raw_encode: HEXBYTES
    lambda: |-
      // Extract minutes and hours hex strings
      std::string hex_month_str = x.substr(0, 2); // First two characters
      std::string hex_year_str = x.substr(2, 2);  // Last two characters
      std::string hex_hours_str = x.substr(4, 2); // First two characters
      std::string hex_day_str = x.substr(6, 2);   // Last two characters
      std::string hex_seconds_str = x.substr(8, 2); // First two characters
      std::string hex_minutes_str = x.substr(10, 2); // Last two characters
      
      // Convert hex strings to decimal integers
      int year = std::stoi(hex_year_str, nullptr, 16);
      int month = std::stoi(hex_month_str, nullptr, 16);
      int day = std::stoi(hex_day_str, nullptr, 16);
      int hours = std::stoi(hex_hours_str, nullptr, 16);
      int minutes = std::stoi(hex_minutes_str, nullptr, 16);
      int seconds = std::stoi(hex_seconds_str, nullptr, 16);

      // Get current local timezone offset
      time_t rawtime;
      ::time(&rawtime);
      struct tm * timeinfo = ::localtime(&rawtime);
      char tz_buffer[10];
      strftime(tz_buffer, sizeof(tz_buffer), "%z", timeinfo); // Returns e.g., "-0600"
      std::string tz_offset(tz_buffer);
      if (tz_offset.length() == 5) {
          tz_offset.insert(3, ":"); // Converts "-0600" to "-06:00"
      } else {
          tz_offset = "Z"; // Fallback to UTC if timezone unavailable
      }

      return str_sprintf("20%02d-%02d-%02dT%02d:%02d:%02d%s", year, month, day, hours, minutes, seconds, tz_offset.c_str());

select:
  # this option map does not appear correct as it's defaulted to a value of 1. Commenting out for how as it's not important to ongoing operations
  #- platform: modbus_controller
  #  modbus_controller_id: inverter_1
  #  name: "Language"
  #  id: inv_language
  #  address: 16
  #  internal: True
  #  value_type: U_WORD
  #  optionsmap: 
  #    "English": 0
  #    "German": 1

  #this option map does not appear correct. Commenting out for how as it's not important to ongoing operations
  #- platform: modbus_controller
  #  modbus_controller_id: inverter_1
  #  name: "Device Type"
  #  id: DTC_DeviceType
  #  address: 19
  #  internal: True
  #  value_type: U_WORD
  #  optionsmap: 
  #    "Default": 0
  #    "XOLTA": 3
  #    "Unknown": 10284
    #[14:08:22.586][E][modbus_controller.select:035]: No option found for mapping 10284

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV Input Model"
    id: pvInputModel
    address: 20
    value_type: U_WORD
    skip_updates: ${skipUpdatesHolding}
    optionsmap: 
      "No PV": 0
      "PV1 Only": 1
      "PV2 Only": 2
      "PV3 Only": 3
      "PV 1&2": 4
      "PV 1&3": 5
      "PV 2&3": 6
      "PV 1&2&3": 7

  # Not able to verify this, unused as far as I can tell.
  - platform: template
    name: "L2N CT Reuse"
    id: FuncEn1_L2NCTReuse
    internal: true
    options: 
      - "none"
      - "SpecLoad"
      - "AC Couple Power"
    set_action: 
      - number.set:
          id: FuncEn1_RawValue
          value: !lambda |-
            int idx = id(FuncEn1_L2NCTReuse).index_of(x).value_or(0);
            int current = (int)id(FuncEn1_RawValue).state;
            return (float)((current & ~0x0300) | (idx << 8));

  - platform: template
    name: "CT Sample Ratio"
    id: FuncEn1_CTSampleRatio
    optimistic: true
    options:
      - "1/1000"
      - "1/3000"
      - "1/2000"
      - "1/4000"
      - "1/6000"
    set_action:
      - number.set:
          id: FuncEn1_RawValue
          value: !lambda |-
            uint16_t val = (uint16_t)id(FuncEn1_RawValue).state;
            val &= ~((1 << 5) | (1 << 6) | (1 << 12) | (1 << 13));
            int index =id(FuncEn1_CTSampleRatio).index_of(x).value_or(0);
            if (index & 0x01) val |= (1 << 5);
            if (index & 0x02) val |= (1 << 6);
            if (index & 0x04) val |= (1 << 12);
            if (index & 0x08) val |= (1 << 13); 
            return (float)val;

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Set System Type"
    id: SetSystemType
    address: 112
    value_type: U_WORD
    skip_updates: ${skipUpdatesHolding}
    optionsmap: 
      "No Parallel": 0
      "Single Phase Parallel Primary": 1
      "Parallel Secondary": 2
      "3 Phase Primary": 3
      "2*208 Primary": 4

      
number:
  #this option is useless to read and change... for documentation only
  #- platform: modbus_controller
  #  modbus_controller_id: inverter_1
  #  name: "MODBUS Address"
  #  id: ComAddr
  #  address: 15
  #  register_type: holding
  #  step: 1
  #  min_value: 0
  #  max_value: 150

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "FuncEnRawValue"
    id: FuncEn_RawValue
    register_type: holding
    address: 21
    internal: true
    on_value:
      - switch.template.publish:
          id: FuncEn_EPSEn
          state: !lambda 'return (bool)((int)x & (1 << 0));'      
      - switch.template.publish:
          id: FuncEn_OVFLoadDerateEn
          state: !lambda 'return (bool)((int)x & (1 << 1));'      
      - switch.template.publish:
          id: FuncEn_DRMSEn
          state: !lambda 'return (bool)((int)x & (1 << 2));'      
      - switch.template.publish:
          id: FuncEn_LVRTEn
          state: !lambda 'return (bool)((int)x & (1 << 3));'      
      - switch.template.publish:
          id: FuncEn_AntiIslandEn
          state: !lambda 'return (bool)((int)x & (1 << 4));'      
      - switch.template.publish:
          id: FuncEn_NeutralDetectEn
          state: !lambda 'return (bool)((int)x & (1 << 5));'      
      - switch.template.publish:
          id: FuncEn_GridOnPowerSSEn
          state: !lambda 'return (bool)((int)x & (1 << 6));'      
      - switch.template.publish:
          id: FuncEn_ACChargeEn
          state: !lambda 'return (bool)((int)x & (1 << 7));'      
      - switch.template.publish:
          id: FuncEn_SWSeamlesslyEn
          state: !lambda 'return (bool)((int)x & (1 << 8));'      
      - switch.template.publish:
          id: FuncEn_SetToStandby
          state: !lambda 'return (bool)((int)x & (1 << 9));'      
      - switch.template.publish:
          id: FuncEn_ForcedDischgEn
          state: !lambda 'return (bool)((int)x & (1 << 10));'      
      - switch.template.publish:
          id: FuncEn_ForcedChgEn
          state: !lambda 'return (bool)((int)x & (1 << 11));'      
      - switch.template.publish:
          id: FuncEn_ISOEn
          state: !lambda 'return (bool)((int)x & (1 << 12));'      
      - switch.template.publish:
          id: FuncEn_GFCIEn
          state: !lambda 'return (bool)((int)x & (1 << 13));'
      - switch.template.publish:
          id: FuncEn_DCIEn
          state: !lambda 'return (bool)((int)x & (1 << 14));'          
      - switch.template.publish:
          id: FuncEn_FeedInGridEn
          state: !lambda 'return (bool)((int)x & (1 << 15));'

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Start PV Volt"
    id: StartPVVolt
    address: 22
    register_type: holding
    unit_of_measurement: "V"
    device_class: voltage
    min_value: 140.0
    max_value: 500.0
    skip_updates: ${skipUpdatesHolding}
    step: 0.1
    # Scale the value for display (Read 900 -> Show 90.0)
    lambda: "return x * 0.1;"
    # Scale the value back for the Modbus write (UI 90.0 -> Write 900)
    write_lambda: "return x * 10.0;" 

  #not sure what this is for...
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Charging Power Percentage"
    id: ChargePowerPercentCMD
    address: 64
    register_type: holding
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    #skip_updates: ${skipUpdatesHolding}
    step: 1

  #not sure what this is for...
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Discharging Power Percentage"
    id: DischgPowerPercentCMD
    address: 65
    register_type: holding
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    #skip_updates: ${skipUpdatesHolding}
    step: 1    

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charge Mode Power Rate"
    id: ACChgPowerCMD
    address: 66
    register_type: holding
    unit_of_measurement: "kW"
    #this differs from LuxPower branded inverters which uses % instead
    device_class: power
    min_value: 0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Charge Mode SOC Limit"
    id: ACChgSOCLimit
    address: 67
    register_type: holding
    unit_of_measurement: "%"
    min_value: 0
    max_value: 101
    step: 1  

  # --- AC Charge Times ---
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgStart1Raw
    address: 68
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgStart1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgEnd1Raw
    address: 69
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgEnd1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgStart2Raw
    address: 70
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgStart2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgEnd2Raw
    address: 71
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgEnd2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgStart3Raw
    address: 72
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgStart3

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ACChgEnd3Raw
    address: 73
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ACChgEnd3
    
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV Priority Charge Mode Power Rate"
    id: ChgFirstPowerCMD
    address: 74
    register_type: holding
    unit_of_measurement: "kW"
    #this differs from LuxPower branded inverters which uses % instead
    device_class: power
    min_value: 0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV Priority Charge Mode SOC Limit"
    id: ChgFirstSOCLimit
    address: 75
    register_type: holding
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1  

  # --- PV Charge Times ---
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgStart1Raw
    address: 76
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgStart1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgEnd1Raw
    address: 77
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgEnd1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgStart2Raw
    address: 78
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgStart2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgEnd2Raw
    address: 79
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgEnd2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgStart3Raw
    address: 80
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgStart3

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: PVChgEnd3Raw
    address: 81
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: PVChgEnd3

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Forced Discharge Mode Power Rate"
    id: ForcedDischgPowerCMD
    address: 82
    register_type: holding
    unit_of_measurement: "kW"
    #this differs from LuxPower branded inverters which uses % instead
    device_class: power
    min_value: 0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Forced Discharge Mode SOC Limit"
    id: ForcedDischgSOCLimit
    address: 83
    register_type: holding
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1  
    
  # --- Forced Discharge Times ---
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgStart1Raw
    address: 84
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgStart1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgEnd1Raw
    address: 85
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgEnd1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgStart2Raw
    address: 86
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgStart2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgEnd2Raw
    address: 87
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgEnd2

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgStart3Raw
    address: 88
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgStart3

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    id: ForcedDischgEnd3Raw
    address: 89
    register_type: holding
    value_type: U_WORD
    internal: true 
    on_value:
      then:
        - component.update: ForcedDischgEnd3

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Lead Acid Absorb Voltage"
    id: LAChargeVoltRef
    address: 99
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    unit_of_measurement: "V"
    device_class: voltage
    min_value: 50.0
    max_value: 59.0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge Volt Cut Off Off-grid"
    id: CutVoltForDischg
    address: 100
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    unit_of_measurement: "V"
    device_class: voltage
    min_value: 40.0
    max_value: 52.0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Charge Current Limit"
    id: ChargeCurr
    address: 101
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    unit_of_measurement: A
    device_class: current
    min_value: 0
    max_value: 250
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge Current Limit"
    id: DischgCurr
    address: 102
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    unit_of_measurement: A
    device_class: current
    min_value: 0
    max_value: 250
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Sell Back Max Power"
    id: MaxBackFlow
    address: 103
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    unit_of_measurement: "kW"
    #this differs from LuxPower branded inverters which uses % instead
    device_class: power
    min_value: 0
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 

  #this is an 18kPV parameter?
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "DischgChgSWCMD"
    id: DischgChgSWCMD
    address: 104
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge SOC Cut Off On-Grid"
    id: EOD
    address: 105
    register_type: holding
    unit_of_measurement: "%"
    min_value: 10
    max_value: 90
    skip_updates: ${skipUpdatesHolding}
    step: 1

  #these appear unused
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "TemprLowerLimitDischg"
    id: TemprLowerLimitDischg
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    address: 106
    device_class: temperature
    unit_of_measurement: "C"
    value_type: U_WORD
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 
    internal: true

  #these appear unused
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "TemprUpperLimitDischg"
    id: TemprUpperLimitDischg
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    address: 107
    device_class: temperature
    unit_of_measurement: "C"
    value_type: U_WORD
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 
    internal: true

  #these appear unused
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "TemprLowerLimitChg"
    id: TemprLowerLimitChg
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    address: 108
    device_class: temperature
    unit_of_measurement: "C"
    value_type: U_WORD
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 
    internal: true

  #these appear unused
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "TemprUpperLimitChg"
    id: TemprUpperLimitChg
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    address: 109
    device_class: temperature
    unit_of_measurement: "C"
    value_type: U_WORD
    step: 0.1
    lambda: "return x * 0.1;"
    write_lambda: "return x * 10.0;" 
    internal: true

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "FuncEn1RawValue"
    id: FuncEn1_RawValue
    register_type: holding
    address: 110
    #internal: true
    on_value:
      then:
        - switch.template.publish:
            id: FuncEn1_ubPVGridOffEn
            state: !lambda 'return (bool)((int)x & (1 << 0));'
        - switch.template.publish:
            id: FuncEn1_ubFastZeroExport
            state: !lambda 'return (bool)((int)x & (1 << 1));'
        - switch.template.publish:
            id: FuncEn1_ubMicroGridEn
            state: !lambda 'return (bool)((int)x & (1 << 2));'
        - switch.template.publish:
            id: FuncEn1_ubBatShared
            state: !lambda 'return (bool)((int)x & (1 << 3));'
        - switch.template.publish:
            id: FuncEn1_ubChgLastEn
            state: !lambda 'return (bool)((int)x & (1 << 4));'
        - switch.template.publish:
            id: FuncEn1_ubBuzzerEn
            state: !lambda 'return (bool)((int)x & (1 << 7));'
        - lambda: |-
            int val = ((int)x >> 8) & 0x03;
            auto option = id(FuncEn1_L2NCTReuse).at(val);
            if (option.has_value()) { id(FuncEn1_L2NCTReuse).publish_state(option.value()); }
        - switch.template.publish:
            id: FuncEn1_ubTakeLoadTogether
            state: !lambda 'return (bool)((int)x & (1 << 10));'                       
        - switch.template.publish:
            id: FuncEn1_ubConsistentCheckMask
            state: !lambda 'return (bool)((int)x & (1 << 11));'
        - switch.template.publish:
            id: FuncEn1_ubAbsoluteZeroExport
            state: !lambda 'return (bool)((int)x & (1 << 14));'
        - switch.template.publish:
            id: FuncEn1_EcoModeEn
            state: !lambda 'return (bool)((int)x & (1 << 15));'
        - lambda: |-
            int i = ((int)x >> 5 & 3) | ((int)x >> 10 & 12);
            auto opts = id(FuncEn1_CTSampleRatio).at(i);
            if (opts.has_value()) { id(FuncEn1_CTSampleRatio).publish_state(opts.value()); }

            

# This is here to ensure that the LED for 'Cloud' isn't half-lit
switch:
  #This is the "cloud" LED, instead of indicating it's connected to EG4, indicate it's connected to HA
  - platform: gpio
    name: "HA API LED"
    id: led_ha_api
    internal: True
    pin:
      number: GPIO13
      mode: OUTPUT
      inverted: True
    restore_mode: ALWAYS_OFF

  #This will indicate it's on the network, has an IP address. This should be regardless of connection via wifi or ethernet
  - platform: gpio
    id: led_network
    internal: True
    name: "Network LED"
    pin:
      number: GPIO15
      mode: OUTPUT
      inverted: True
    restore_mode: ALWAYS_OFF

  #This effectively is the power light. It's always on when plugged into the inverter and the code has at least started
  - platform: gpio
    id: led_inv
    name: "inv LED"
    internal: True
    pin:
      number: GPIO33
      mode: OUTPUT
      inverted: True
    restore_mode: ALWAYS_ON

  - platform: template
    name: "EPS Power Backup"
    id: FuncEn_EPSEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 0);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 0);'

  - platform: template
    name: "Overfrequency Load Reduction Enable"
    id: FuncEn_OVFLoadDerateEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 1);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 1);'

  - platform: template
    name: "DRMS Enable"
    id: FuncEn_DRMSEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 2);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 2);'

  - platform: template
    name: "Low Voltage Ride-through Enable"
    id: FuncEn_LVRTEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 3);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 3);'

  - platform: template
    name: "Anti Islanding Enable"
    id: FuncEn_AntiIslandEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 4);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 4);'

  - platform: template
    name: "Ground Neutral Detection Enable"
    id: FuncEn_NeutralDetectEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 5);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 5);'

  - platform: template
    name: "On-grid Power Soft Start Enable"
    id: FuncEn_GridOnPowerSSEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 6);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 6);'

  - platform: template
    name: "AC Charge Mode Enable"
    id: FuncEn_ACChargeEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 7);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 7);'

  - platform: template
    name: "Seamless Off-grid mode switching enable"
    id: FuncEn_SWSeamlesslyEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 8);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 8);'

  - platform: template
    name: "Power On - Standby Off"
    id: FuncEn_SetToStandby
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 9);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 9);'

  - platform: template
    name: "Forced Discharge Mode Enable"
    id: FuncEn_ForcedDischgEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 10);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 10);'

  - platform: template
    name: "Forced Charge Enable"
    id: FuncEn_ForcedChgEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 11);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 11);'

  - platform: template
    name: "ISO Enable"
    id: FuncEn_ISOEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 12);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 12);'

  - platform: template
    name: "GFCI Enable"
    id: FuncEn_GFCIEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 13);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 13);'

  - platform: template
    name: "DCI Enable"
    id: FuncEn_DCIEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 14);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 14);'

  - platform: template
    name: "Grid Sell Back Enable (Changing Resets Max Power)"
    id: FuncEn_FeedInGridEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state | (1 << 15);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn_RawValue
                value: !lambda 'return (int)id(FuncEn_RawValue).state & ~(1 << 15);'

  #This is an 18kPV parameter?
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AutoTestStart"
    id: AutoTestStart
    address: 98
    register_type: holding
    skip_updates: ${skipUpdatesHolding}
    internal: true

  #This throws an error and flips back off when I try to enable it. I'm assuming this can't be enabled unless the battery setting is set to none first.
  - platform: template
    name: "EPS No Batteries (Likely requires Battery Type set to none First)"
    id: FuncEn1_ubPVGridOffEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 0);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 0);'

  - platform: template
    name: "Grid Sell Fast Zero Export"
    id: FuncEn1_ubFastZeroExport
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 1);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 1);'

  #Based on LuxPower documentation, this allows the inverter to use the Grid port as a generator port.
  #Appears to be use-able in concert with the Dry Ports, but it's too cold right now to see if those work.
  - platform: template
    name: "Micro Grid Enable"
    id: FuncEn1_ubMicroGridEn
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 2);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 2);'

  - platform: template
    name: "Battery Shared"
    id: FuncEn1_ubBatShared
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 3);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 3);'

  - platform: template
    name: "Battery Charge Last"
    id: FuncEn1_ubChgLastEn
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 4);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 4);'

  #Tried flipping this, did not feel the relays on the FB click. Will come back to explore this further when it's not so frigid outside
  - platform: template
    name: "Buzzer or Dry Contactor Control"
    id: FuncEn1_ubBuzzerEn
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 7);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 7);'

  #This option is there... does stuff, but is unused by the EG4 platform
  - platform: template
    name: "Take Load Together On-grid"
    id: FuncEn1_ubTakeLoadTogether
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 10);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 10);'

  #no clue what this may be for.
  - platform: template
    name: "Consistent Check Mask"
    id: FuncEn1_ubConsistentCheckMask
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 11);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 11);'

  #no clue what this may be for
  - platform: template
    name: "Absolute Zero Export"
    id: FuncEn1_ubAbsoluteZeroExport
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 14);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 14);'

  #no clue what his may be for
  - platform: template
    name: "EcoMode"
    id: FuncEn1_EcoModeEn
    internal: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state | (1 << 15);'
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(FuncEn1_RawValue).has_state();'
          then:
            - number.set:
                id: FuncEn1_RawValue
                value: !lambda 'return (int)id(FuncEn1_RawValue).state & ~(1 << 15);'


datetime:
  # --- AC Charge Mode Times ---
  - platform: template
    id: ACChgStart1
    name: "AC Charge Mode T1 Start"
    type: time
    lambda: &time_lambda |-
      if (!id(ACChgStart1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgStart1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgStart1Raw).state;
            then:
              - number.set:
                  id: ACChgStart1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ACChgEnd1
    name: "AC Charge Mode T1 Stop"
    type: time
    lambda: |-
      if (!id(ACChgEnd1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgEnd1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgEnd1Raw).state;
            then:
              - number.set:
                  id: ACChgEnd1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ACChgStart2
    name: "AC Charge Mode T2 Start"
    type: time
    lambda: |-
      if (!id(ACChgStart2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgStart2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgStart2Raw).state;
            then:
              - number.set:
                  id: ACChgStart2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ACChgEnd2
    name: "AC Charge Mode T2 Stop"
    type: time
    lambda: |-
      if (!id(ACChgEnd2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgEnd2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgEnd2Raw).state;
            then:
              - number.set:
                  id: ACChgEnd2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ACChgStart3
    name: "AC Charge Mode T3 Start"
    type: time
    lambda: |-
      if (!id(ACChgStart3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgStart3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgStart3Raw).state;
            then:
              - number.set:
                  id: ACChgStart3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ACChgEnd3
    name: "AC Charge Mode T3 Stop"
    type: time
    lambda: |-
      if (!id(ACChgEnd3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ACChgEnd3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ACChgEnd3Raw).state;
            then:
              - number.set:
                  id: ACChgEnd3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  # --- PV Priority Charge Mode Times ---
  - platform: template
    id: PVChgStart1
    name: "PV Priority Charge Mode T1 Start"
    type: time
    lambda: |-
      if (!id(PVChgStart1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgStart1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgStart1Raw).state;
            then:
              - number.set:
                  id: PVChgStart1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: PVChgEnd1
    name: "PV Priority Charge Mode T1 Stop"
    type: time
    lambda: |-
      if (!id(PVChgEnd1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgEnd1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgEnd1Raw).state;
            then:
              - number.set:
                  id: PVChgEnd1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: PVChgStart2
    name: "PV Priority Charge Mode T2 Start"
    type: time
    lambda: |-
      if (!id(PVChgStart2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgStart2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgStart2Raw).state;
            then:
              - number.set:
                  id: PVChgStart2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: PVChgEnd2
    name: "PV Priority Charge Mode T2 Stop"
    type: time
    lambda: |-
      if (!id(PVChgEnd2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgEnd2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgEnd2Raw).state;
            then:
              - number.set:
                  id: PVChgEnd2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: PVChgStart3
    name: "PV Priority Charge Mode T3 Start"
    type: time
    lambda: |-
      if (!id(PVChgStart3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgStart3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgStart3Raw).state;
            then:
              - number.set:
                  id: PVChgStart3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: PVChgEnd3
    name: "PV Priority Charge Mode T3 Stop"
    type: time
    lambda: |-
      if (!id(PVChgEnd3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(PVChgEnd3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(PVChgEnd3Raw).state;
            then:
              - number.set:
                  id: PVChgEnd3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  # --- Forced Discharge Mode Times ---
  - platform: template
    id: ForcedDischgStart1
    name: "Forced Discharge Mode T1 Start"
    type: time
    lambda: |-
      if (!id(ForcedDischgStart1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgStart1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgStart1Raw).state;
            then:
              - number.set:
                  id: ForcedDischgStart1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ForcedDischgEnd1
    name: "Forced Discharge Mode T1 Stop"
    type: time
    lambda: |-
      if (!id(ForcedDischgEnd1Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgEnd1Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgEnd1Raw).state;
            then:
              - number.set:
                  id: ForcedDischgEnd1Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ForcedDischgStart2
    name: "Forced Discharge Mode T2 Start"
    type: time
    lambda: |-
      if (!id(ForcedDischgStart2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgStart2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgStart2Raw).state;
            then:
              - number.set:
                  id: ForcedDischgStart2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ForcedDischgEnd2
    name: "Forced Discharge Mode T2 Stop"
    type: time
    lambda: |-
      if (!id(ForcedDischgEnd2Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgEnd2Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgEnd2Raw).state;
            then:
              - number.set:
                  id: ForcedDischgEnd2Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ForcedDischgStart3
    name: "Forced Discharge Mode T3 Start"
    type: time
    lambda: |-
      if (!id(ForcedDischgStart3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgStart3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgStart3Raw).state;
            then:
              - number.set:
                  id: ForcedDischgStart3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

  - platform: template
    id: ForcedDischgEnd3
    name: "Forced Discharge Mode T3 Stop"
    type: time
    lambda: |-
      if (!id(ForcedDischgEnd3Raw).has_state()) return {};
      uint16_t val = (uint16_t)id(ForcedDischgEnd3Raw).state;
      esphome::ESPTime time_val;
      time_val.hour = (uint8_t)(val & 0xFF);
      time_val.minute = (uint8_t)(val >> 8);
      time_val.second = 0;
      return time_val;
    set_action:
      then:
        - if:
            condition:
              lambda: |-
                uint16_t new_raw = (uint16_t)((x.minute << 8) | (x.hour & 0xFF));
                return new_raw != (uint16_t)id(ForcedDischgEnd3Raw).state;
            then:
              - number.set:
                  id: ForcedDischgEnd3Raw
                  value: !lambda "return (uint16_t)((x.minute << 8) | (x.hour & 0xFF));"

              
